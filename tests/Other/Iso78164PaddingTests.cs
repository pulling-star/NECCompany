using System;
using NSec.Experimental;
using Xunit;

namespace NSec.Tests.Other
{
    public static class Iso78164PaddingTests
    {
        public static readonly TheoryData<int, byte[], byte[]> TestVectors8 = new()
        {
            { 8, new byte[] { 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, new byte[] { } },
            { 8, new byte[] { 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, new byte[] { 0x01, } },
            { 8, new byte[] { 0x01, 0x02, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, }, new byte[] { 0x01, 0x02, } },
            { 8, new byte[] { 0x01, 0x02, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, }, new byte[] { 0x01, 0x02, 0x03, } },
            { 8, new byte[] { 0x01, 0x02, 0x03, 0x04, 0x80, 0x00, 0x00, 0x00, }, new byte[] { 0x01, 0x02, 0x03, 0x04, } },
            { 8, new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x80, 0x00, 0x00, }, new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, } },
            { 8, new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x80, 0x00, }, new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, } },
            { 8, new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x80, }, new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, } },
            { 8, new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, } },
            { 8, new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, } },
            { 8, new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, }, new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, } },
            { 8, new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x80, 0x00, 0x00, 0x00, 0x00, }, new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, } },
            { 8, new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x80, 0x00, 0x00, 0x00, }, new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, } },
            { 8, new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x80, 0x00, 0x00, }, new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, } },
            { 8, new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x80, 0x00, }, new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, } },
            { 8, new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x80, }, new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, } },
        };

        [Theory]
        [MemberData(nameof(TestVectors8))]
        public static void Pad(int blockSize, byte[] padded, byte[] unpadded)
        {
            var expected = padded;
            var actual = Iso78164Padding.Pad(unpadded, blockSize);
            Assert.Equal(expected, actual);
        }

        [Theory]
        [MemberData(nameof(TestVectors8))]
        public static void PadSpan(int blockSize, byte[] padded, byte[] unpadded)
        {
            var expected = padded;
            var actual = new byte[Iso78164Padding.GetPaddedLength(unpadded.Length, blockSize)];
            Iso78164Padding.Pad(unpadded, blockSize, actual);
            Assert.Equal(expected, actual);
        }

        [Theory]
        [MemberData(nameof(TestVectors8))]
        public static void Unpad(int blockSize, byte[] padded, byte[] unpadded)
        {
            var expected = unpadded;
            var actual = Iso78164Padding.Unpad(padded, blockSize);
            Assert.NotNull(actual);
            Assert.Equal(expected, actual);
        }

        [Theory]
        [MemberData(nameof(TestVectors8))]
        public static void UnpadSpan(int blockSize, byte[] padded, byte[] unpadded)
        {
            var expected = unpadded;
            Assert.True(Iso78164Padding.Unpad(padded, blockSize, out var actual));
            Assert.Equal(expected, actual.ToArray());
        }

        [Theory]
        [MemberData(nameof(TestVectors8))]
        public static void DecodeCorruptedPadding(int blockSize, byte[] padded, byte[] unpadded)
        {
            for (var i = unpadded.Length; i < padded.Length; i++)
            {
                var corrupted = padded.AsSpan().ToArray();
                corrupted[i] = 0xFF;
                Assert.Null(Iso78164Padding.Unpad(corrupted, blockSize));
                Assert.False(Iso78164Padding.Unpad(corrupted, blockSize, out var actual));
                Assert.True(actual.IsEmpty);
            }
        }

        [Theory]
        [MemberData(nameof(TestVectors8))]
        public static void DecodeInvalidLength(int blockSize, byte[] padded, byte[] unpadded)
        {
            for (var i = 1; i < blockSize; i++)
            {
                var corrupted = padded.AsSpan(0, padded.Length - i).ToArray();
                Assert.Null(Iso78164Padding.Unpad(corrupted, blockSize));
                Assert.False(Iso78164Padding.Unpad(corrupted, blockSize, out var actual));
                Assert.True(actual.IsEmpty);
            }
        }

        [Fact]
        public static void UnpadEmpty()
        {
            Assert.Null(Iso78164Padding.Unpad(ReadOnlySpan<byte>.Empty, 8));
            Assert.False(Iso78164Padding.Unpad(ReadOnlySpan<byte>.Empty, 8, out var actual));
            Assert.True(actual.IsEmpty);
        }
    }
}
